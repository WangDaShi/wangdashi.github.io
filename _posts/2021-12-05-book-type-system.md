---

layout: posts
title: 读书笔记《编程与类型系统》(待完成)

---
### 前言

这本书和想象的不一样。感觉类型系统是一个和各方面牵连在一起的领域，没办法单独“拎”出来独立的讲。本书以TypeScript为例子来讲解，基本上混杂了TypeScript的很多语法。甚至很多章节读起来感觉没什么必要，没什么新的东西。而到了最后一章反而读不懂了。总之，先把书中内容回顾整理一下，放在这里。

### 一、类型简介

1. 类型的存在是用来告诉系统存储的数据到底是什么，计算机好知道该对这块“数据”做什么操作。

2. 一般来说编程语言会内置一些基础的类型，计算机可以知道这个“数据”的操作规则。

3. 另一方面类型系统也是用来约束编程者，编译器可以通过类型信息检查程序的操作是否“合法”。

4. 根据编程语言对类型的限制的多少可以把语言分为“强类型”和“弱类型”，两种模式各有利弊。

### 二、基本类型

1. 类型其实可以看做是数学意义上的“范畴”，即使一组值的集合。

2. 一般来说编程言语都会有几种内置的基础类型：数值、字符、布尔、空类型。

3. 空类型是一种特殊的类型，该类型的集合只有一个值，表示的是“空”。在java里就是Void，在其它语言里可能是nil。空类型和null其实是两个东西。

4. 对于数值类型，操作不可避免会出现数值的溢出问题。对于数值来说，由于底层是二进制保存，自然会出现精度问题。另外由于数据的存储不可能是无限的（无论是多少个字节），总会有超过上下限的情况（最大值或者最小值）。对于这样的情况，一般只有几种应对方法：
    * 不管，直接把高位给舍弃掉
    * 检查出来，报错
    * 取边界值

5. 字符是一种特殊的类型，其实是用类型集合中的每一个值映射现实中的一个“字符”。对于字符不像数值计算，IEEE已经给出了非常同意的规范，所以在发展的过程当中前后出现了很多种不同的编码规范，也就是不同的“映射”规则。目前Unicode是最流行的。

6. Unicode规范有多个实现方法，对于UTF-8这样的变长规则，每一个值的存储大小是不一样的。

7. 数组是一个特殊的类型，其实可以理解为一组类型相同的值的集合。重点是数组的大小是固定的。其实数组就相当于是告诉计算机这一块内存里是**连续**存放着**N**个类型是**X**的值。这样计算机就知道该怎么办了。

8. 最后一个类型就是“引用”。引用和上面其它的基础类型搭配，就可以设计出各式各样复杂的**复合类型**。比如动态列表（List）,Map，二叉树等等。引用被看做是一种类型，可以认为是一个集合，里面的值都是**指针**。而指针可以指向各种位置，各种类型。实际上引用在编程语言中是隐性的存在（至少在Java中是这样的）。

9. null不是一个类型，它只是用来表示“空”，就是什么都不是。一些语言里所有类型的值都可以是null，其实就是null属于所有的集合。但从类型设计的角度来看是非常有问题的。

### 三、组合

1. **或类型（变体）**：有时候我们希望表示一个值既可能是类型A也可能是类型B。这样的话在有些场景下可以简化代码的编写，更加灵活。在Java中的异常里有这样的语法（通过符号\|来表示或的意思）。而在一些语言中（go、ts）则提供了更加通用的语法。对这个值操作的时候，可以先判断实际是什么类型，然后按这个类型进行操作。在一些语言中该语法经常用来实现正常情况和错误情况的处理：
    
    > 比如在一些语言中方法可以返回一个正常的返回类型和错误的组合类型，调用者必须先判断时候出现了错误，然后才能对值进行操作。而在java这样的语言中，虽然没有语法上面的直接支持，但是也通过Optional类来实现相同的逻辑。
    
    > 其实类型系统的一些功能其实就是在语法层面上提供一些对编程的限制、或者是支持。从而让编写者更方便。至于把功能理解成类型，还是其它比不是很重要。

2. 在go这样的类型中可以返回值可以返回多个值，这样也可以实现类似上面的操作

2. **元组**：对于C语言来说就是结构体，对于Java来说就是没有方法的类。就是表示一个类型包含了多个类型。

3. **枚举**：对于基础类型，每个集合中的值的数量都是有限的，从最小的一个（void）到非常多个（字符）。而枚举就是提供了一种功能，使编程者可以设计一种数量固定的类型。这种类型的值是有限的，且都是指定的。枚举类型对数据进行了限制，所以使用起来更安全，更不容易出错（人都是容易出错的，而机器不会）。

4. **void、undefined和null**: void很好理解，其实它只是用来表示方法没有返回值，同时还要和类型系统不冲突，所以设计了这么一个类型。undefined表示这个值还没有定义，还不知道是什么类型，只有在动态类型里才有意义，因为在Java这样的静态语言里不可能存在这样的情况。而null的存在导致了很多的问题，因为它可以是任何类型的值，任何地方的值都有可能是null。所以非常容易出现空指针的情况。

    > null的设计有问题很容易理解，但问题是：对于Java这样的语言，如果去除掉了null该怎么设计呢？

5. **异常**：该类型用来表示计算机运行过程中出现的错误。

### 四、类型安全

1. **类型约束**：使用基础类型的时候经常有的一个问题是：该类型要表示的实际含义决定了该类型的一些约束。而这个约束在基础类型本身是没有限制的。比如使用int类型表示人的年龄，但是人是不可能活超过200岁的，但是int类型是可以的。这样的话就容易犯错误，出现了不应该出现的情况，但是在类型检查的时候发现不了。
对于这样的情况，就需要对类型进行约束，比如代码里添加类型检查，把基础类型封装成class。为了编程的规范，更不容易犯错了，更推荐的是对基础类型进行封装，然后再去表示具体的业务。

2. **类型的转换**：就是把一个类型的值转换成另一个类型的值。对于数值这样的基础类型，一般语言都提供了转换规则：精度高的向精度低的转换则隐式转换。高精度向低精度的转换是显式转换，并带来精度的丢失。类型的转换其实就是告诉计算机把这一块内存当做另一个类型使用。转换能够成功的前提是这块**内存**中包含了新类型需要的足够的信息。

3.  向上转型、向下转型、逆变、协变、不变：
    1. **向上**：子类转换成父类，按照面向对象的设计原则，这个过程不会出现问题。注意的是其实内存中实际的信息没有发生变化。
    2. **向下**：前提是要转换的值中实际上包含了对应的子类型的信息，否则是不可能转换成功的。毕竟没有对应的数据，计算机也没有办法。
    3. **协变**：如果集合的类型从属关系和集合中类型的从属关系是一样的，就是协变。（因为是跟着变的）
    4. **逆变**：如果集合的类型从属关系和集合中类型的从属各系是反着的，就是逆变。
    5. **不变**：集合的类型和集合中的类型之间没有任何关系的话，就是不变。
    6. **双变**：不是太懂

4. **序列化**：其实就是把一个值用字符串的形式把数据保存下来，要保证基于序列化的数据信息可以完全把值给恢复过来。

### 五、函数类型

1. 函数也可以被看做是一种类型。在函数式的语言中函数甚至是第一等级的类型。

2. 一个函数的类型由函数的签名决定（输入参数类型 + 返回结果类型）。

3. 使用函数类型可以实现**惰性求知**，可以替代**设计模式**，更灵活的实现。

4. 可以实现**闭包**（对于Java这样的语言，实现了部分的函数式，就不允许闭包）。

5. 有了函数式就可以实现map、filter、reduce这样的通用的功能。

6. 异步编程和Promise链式回调（这部分和类型系统其实没什么关系）。

### 六、子类型

1. 一般来说对于面向对象来说子类型就是“子类”。

2. TypeScript中的各式各样的神奇类型：undefined、void、null、unknown、any。void容易理解，只是用来标识没有返回值一个作用；any类似于Java中的Object，标识这个值可能是任何类型；unknown表示未知的类型，和any的区别是编译器会对unknown进行类型检查，其用意是希望两者用着不同的场景；undefined表示这个值其实啥都不是，还没有被指定任何的类型；null是个奇葩；

3. 对于ts这样的动态语言，只要一个类型可以转换成另一个类型，那么就可以说一个是另一个的子类型。

### 七、面向对象

1. 继承是OO的基础功能。

2. 但是现实世界太复杂，通过对世界上的万物进行分类，通过继承来清晰的表达式不可能的。

3. 为了更灵活的表达，就需要接口，或者多重继承。

4. 接口其实是一种**契约**，约束了类型要提供的功能，但是不要求具体的实现。也可以使得模块的内部实现和外部功能解耦。而且相比于父类的继承关系，实现了接口的对象之间是松散的约束。

5. 即使有了接口，OO还是有很多场景解决不了，所以提倡**组合**优于继承。尽量使用组合，避免使用继承。

6. 然而，即使这样，OO还是表达力不够，所以就有了**混入（mixin）**。混入可以让一个已经继承了父类的类型中**掺入**另一个类型的一些功能。
    
    > 对于python这样的动态语言，这样的实现是简单的，直接就多重继承就行。但需要注意的是**多重继承**和**mixin**其实是有区别的。mixin强调的是在已有的类的结构前提下往里面**掺入**希望添加的功能（注意是功能，所以就是方法），而不是要求像多重继承那样提供更多的要求（新继承的类型是一个单独的类，可以有数据，被继承的对象本身也可以被看做是新继承的类）。在python这样的语言中，虽然是通过多重继承的方式来实现mixin，但是按照规范应该要保证：
        <br>1. 要混入的类型不能被new，因为它只是提供功能
        <br> 2. 被混入的类型不要干扰现有的类
        <br> 3. 被混入的类型只提供功能，不提供完成的对象能力
    
    > 对于Java这样的语言，只提供了劣化版本的mixin：接口中的default方法。

    > 对于一些scala这样的语言在语法层面上提供了对应的功能（trait）

### 八、泛型！泛型！泛型！

1. 泛型提取了编程的模板，可以编写通用的代码。

2. 基于泛型重新设计了集合和流处理（map、reduce、sort、filter），使用了接口、组合、接口和功能的配合等，基本上和Java中的集合设计一样。

### 九、高阶类型

1. **高阶类型**: 在Java的泛型设计中虽然可以写出非常复杂的泛型类型。

```java
function <T> void test(List<Map<String,T> list){
    // TODO
}
```

但是并不支持下面这样的情况：

```java
fucntion <A,B> void test(A<B> p){
    // TODO
}
```

而这个格式就是高阶类型，它是关于类型的类型。用集合的角度来说就是这个类型对应的集合中的所有**值**都是一个**类型**。而Java中泛型虽然可以嵌套，但是必须要指定具体的类型。可以看出高阶类型是把类型本身看做了一个值。是对类型的抽象，支持了高阶类型就可以无限的嵌套类型。

2. **群论**：在数学意义上一个群的定义包含了两部分信息：一个集合、集合中各个元素之间的运算关系。可以看出在知晓了这两部分之后，相当于是定义了一个世界和世界运行的规则。而群论就是对给定的世界的性质的研究。对应到编程的类型系统中，就可以认为一个类型（一个集合）和类型中各元素的操作规则就可以被看做是一个群。
    函子其实就是编程语言的设计者从群论的数学资源中获得的一个看待编程计算的角度，从而设计出来的一些语法，来便于使用者的操作。当然，前提是能力理解这个语法和背后的用意。

3. **函子**：
    没懂

4. **单子**：

    没懂
